const path=require("path"),better_sqlite3=require("better-sqlite3");
/**
* The easier and safer better-sqlite3 package.
* @param {Object} OPTIONS - The options of better-sqlite3.
* @param {String} OPTIONS.PATH - The database path.
* @param {Function} CALLBACK - The callback function.
* @returns {Object}
*/
module.exports=(async(OPTIONS,CALLBACK)=>await new Promise(async(t,i)=>{try{async function w(a,t){return await new Promise(async(t,i)=>{try{return await t("string"==typeof a&&await String(await a).length>0)}catch(a){return await i(await a)}}).then(async a=>"function"==typeof t?await t({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof t?await t({SUCCESS:!1,ERROR:await a}):await i(await a))}async function E(a,t){return await new Promise(async(t,i)=>{try{return"string"!=typeof a&&(a=await JSON.stringify(await a)),"object"==typeof(a=await JSON.parse(await a))&&null!=await a&&await Object.keys(await a).length>0?await t(!0):await t(!1)}catch(a){return await t(!1)}}).then(async a=>"function"==typeof t?await t({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof t?await t({SUCCESS:!1,ERROR:await a}):await i(await a))}async function n(a,t){return await new Promise(async(t,i)=>{try{return await E(await a,async w=>1==await w.SUCCESS?1==await w.VALUE&&"object"==typeof a.VALUE&&"function"==typeof a.FILTER?await t(await Object.fromEntries(await Object.entries(await a.VALUE).filter(await a.FILTER))):await t(void 0):await i(await a.ERROR))}catch(a){return await i(await a)}}).then(async a=>"function"==typeof t?await t({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>{if("function"==typeof t)return await t({SUCCESS:!1,ERROR:await a});throw await a})}let e=await OPTIONS;0==await E(await e)&&(e=Object({PATH:await e})),(0==await w(await e.PATH)||await path.extname(await e.PATH).length<2)&&(e.PATH="database.sqlite");const r=await new better_sqlite3(await path.resolve(await path.join(await e.UNSAFE_PATH==true?await __dirname:await process.cwd(),await e.PATH)),await n({VALUE: await e,FILTER: ([k, v]) => k != `PATH`})),c={TABLE:{
/**
* Retrieves all tables from the database.
* @param {Function} CALLBACK - The callback function.
* @returns {Object}
*/
ALL:async CALLBACK=>await new Promise(async(a,t)=>{try{const i=await Object();for await(const a of await r.prepare("SELECT name FROM sqlite_master").all())i[await a.name]=await c.TABLE.GET(await a.name);return await a(await i)}catch(a){return await t(await a)}}).then(async t=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await t}):await t).catch(async t=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await t}):await i(await t)),
/**
* Checks whether the given table exists or not.
* @param {String} ID - The table id.
* @param {Function} CALLBACK - The callback function.
* @returns {Boolean}
*/
HAS:async(ID,CALLBACK)=>await new Promise(async(t,i)=>{try{if(1==await w(await ID)){const i=await r.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name=(?)").get(await ID);return 1==await E(await i)&&1==await w(await i.name)&&await i.name==await ID&&0==await isNaN(await Number(await r.prepare(`SELECT VALUE FROM ${await i.name} WHERE ID = (?)`).get("READ_ONLY").VALUE))?await t(!0):await t(!1)}return await t(!1)}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Indicates whether the table is read-only or not.
* @param {String} ID - The table id.
* @param {Function} CALLBACK - The callback function.
* @returns {Boolean}
*/
IS_READ_ONLY:async(ID,CALLBACK)=>await new Promise(async(t,i)=>{try{return await c.TABLE.HAS(await ID,async w=>1==await w.SUCCESS?1==await w.VALUE?await t(1==await r.prepare(`SELECT VALUE FROM ${await ID} WHERE ID = (?)`).get("READ_ONLY").VALUE):await t(!1):await i(await w.ERROR))}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Retrieves values from the given table.
* @param {String} ID - The table id.
* @param {Function} CALLBACK - The callback function.
* @returns {Object}
*/
GET:async(ID,CALLBACK)=>await new Promise(async(t,i)=>{try{return await c.ALL(await ID,async a=>1==await a.SUCCESS?await t(await a.VALUE):await i(await a.ERROR))}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Create a table if it does not exist.
* @param {Object} DATA
* @param {String} DATA.ID - The table id.
* @param {Boolean} DATA.READ_ONLY - Sets the table read-only or not.
* @param {Function} CALLBACK - The callback function.
* @returns {Boolean}
*/
SET:async(DATA,CALLBACK)=>await new Promise(async(t,i)=>{try{return 0==await E(await DATA)&&(DATA=await Object({ID:await DATA})),await c.TABLE.HAS(await DATA.ID,async E=>1==await E.SUCCESS?1==await E.VALUE?await t(!0):1==await w(await DATA.ID)?(await r.prepare(`CREATE TABLE IF NOT EXISTS ${await DATA.ID} (ID TEXT, READ_ONLY INTEGER, VALUE TEXT)`).run(),await r.prepare(`INSERT INTO ${await DATA.ID} (ID,READ_ONLY,VALUE) VALUES (?,?,?)`).run("READ_ONLY",1,1==await DATA.READ_ONLY?1:0),await t(!0)):await t(!1):await i(await E.ERROR))}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Delete a table.
* @param {String} ID - The table id.
* @param {Function} CALLBACK - The callback function.
* @returns {Boolean}
*/
DEL:async(ID,CALLBACK)=>await new Promise(async(t,i)=>{try{return await c.TABLE.HAS(await ID,async w=>1==await w.SUCCESS?1==await w.VALUE&&0==await r.prepare(`SELECT VALUE FROM ${await ID} WHERE ID = (?)`).get("READ_ONLY").VALUE?(await r.prepare(`DROP TABLE IF EXISTS ${await ID}`).run(),await t(!0)):await t(!1):await i(await w.ERROR))}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a))},
/**
* Retrieves values from the given table.
* @param {String} TABLE - The table id.
* @param {Function} CALLBACK - The callback function.
* @returns {Object}
*/
ALL:async(TABLE,CALLBACK)=>await new Promise(async(t,i)=>{try{return await c.TABLE.HAS(await TABLE,async w=>{if(1==await w.SUCCESS){const i=await Object();if(1==await w.VALUE){for await(const t of await r.prepare(`SELECT * FROM ${await TABLE} WHERE ID IS NOT NULL`).iterate())"READ_ONLY"!=await t.ID&&(i[await t.ID]=await n({VALUE:await t,FILTER:([a,t])=>1==["ID","READ_ONLY"].every(t=>a!=t)}));return await t(await i)}return await t(await i)}return await i(await w.ERROR)})}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Checks whether the given id exists or not.
* @param {Object} DATA
* @param {String} DATA.TABLE - The table id.
* @param {String} DATA.ID - The id.
* @param {Function} CALLBACK - The callback function.
* @returns {Boolean}
*/
HAS:async(DATA,CALLBACK)=>await new Promise(async(t,i)=>{try{return 1==await E(await DATA)&&1==await w(await DATA.TABLE)&&1==await w(await DATA.ID)&&"READ_ONLY"!=await DATA.ID?await c.TABLE.HAS(await DATA.TABLE,async n=>{if(1==await n.SUCCESS){if(1==await n.VALUE){const i=await r.prepare(`SELECT * FROM ${await DATA.TABLE} WHERE ID = (?)`).get(await DATA.ID);return await t(1==await E(await i)&&1==await w(await i.ID)&&0==await isNaN(await Number(await i.READ_ONLY))&&(1==await w(await i.VALUE)||0==await isNaN(await Number(await i.VALUE))||1==await Buffer.isBuffer(await i.VALUE)))}return await t(!1)}return await i(await n.ERROR)}):await t(!1)}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Indicates whether the id is read-only or not.
* @param {Object} DATA
* @param {String} DATA.TABLE - The table id.
* @param {String} DATA.ID - The id.
* @param {Function} CALLBACK - The callback function.
* @returns {Boolean}
*/
IS_READ_ONLY:async(DATA,CALLBACK)=>await new Promise(async(t,i)=>{try{return 1==await E(await DATA)&&1==await w(await DATA.TABLE)&&1==await w(await DATA.ID)&&"READ_ONLY"!=await DATA.ID?await c.HAS({TABLE:await DATA.TABLE,ID:await DATA.ID},async w=>1==await w.SUCCESS?1==await w.VALUE?await t(1==await r.prepare(`SELECT READ_ONLY FROM ${await DATA.TABLE} WHERE ID = (?)`).get(await DATA.ID).READ_ONLY):await t(!1):await i(await w.ERROR)):await t(!1)}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Retrieves the id of a given table.
* @param {Object} DATA
* @param {String} DATA.TABLE - The table id.
* @param {String} DATA.ID - The id.
* @param {Function} CALLBACK - The callback function.
* @returns {any}
*/
GET:async(DATA,CALLBACK)=>await new Promise(async(t,i)=>{try{return 1==await E(await DATA)&&1==await w(await DATA.TABLE)&&1==await w(await DATA.ID)&&"READ_ONLY"!=await DATA.ID?await c.HAS({TABLE:await DATA.TABLE,ID:await DATA.ID},async w=>1==await w.SUCCESS?1==await w.VALUE?await t(await r.prepare(`SELECT VALUE FROM ${await DATA.TABLE} WHERE ID = (?)`).get(await DATA.ID).VALUE):await t(void 0):await i(await w.ERROR)):await t(void 0)}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Create or modify an id.
* @param {Object} DATA
* @param {String} DATA.TABLE - The table id.
* @param {String} DATA.ID - The id.
* @param {any} DATA.VALUE - The value of the id.
* @param {Boolean} DATA.READ_ONLY - Sets the id as read-only or not.
* @param {Function} CALLBACK - The callback function.
* @returns {any}
*/
SET:async(DATA,CALLBACK)=>await new Promise(async(t,i)=>{try{return 1!=await E(await DATA)||1!=await w(await DATA.TABLE)||1!=await w(await DATA.ID)||"READ_ONLY"==await DATA.ID||1!=await w(await DATA.VALUE)&&0!=await isNaN(await Number(await DATA.VALUE))&&1!=await Buffer.isBuffer(await DATA.VALUE)?await t(void 0):await c.HAS({TABLE:await DATA.TABLE,ID:await DATA.ID},async w=>1==await w.SUCCESS?1==await w.VALUE&&0==await r.prepare(`SELECT VALUE FROM ${await DATA.TABLE} WHERE ID = (?)`).get("READ_ONLY").VALUE&&0==await r.prepare(`SELECT READ_ONLY FROM ${await DATA.TABLE} WHERE ID = (?)`).get(await DATA.ID).READ_ONLY?(await r.prepare(`UPDATE ${await DATA.TABLE} SET VALUE = (?) WHERE ID = (?)`).run(await DATA.VALUE,await DATA.ID),await t(await r.prepare(`SELECT VALUE FROM ${await DATA.TABLE} WHERE ID = (?)`).get(await DATA.ID).VALUE)):0==await w.VALUE?("boolean"!=typeof DATA.READ_ONLY&&(DATA.READ_ONLY=!1),await r.prepare(`INSERT INTO ${await DATA.TABLE} (ID,READ_ONLY,VALUE) VALUES (?,?,?)`).run(await DATA.ID,1==await DATA.READ_ONLY?1:0,await DATA.VALUE),await t(await r.prepare(`SELECT VALUE FROM ${await DATA.TABLE} WHERE ID = (?)`).get(await DATA.ID).VALUE)):await t(void 0):await i(await w.ERROR))}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a)),
/**
* Delete an id.
* @param {Object} DATA
* @param {String} DATA.TABLE - The table id.
* @param {String} DATA.ID - The id.
* @param {Function} CALLBACK - The callback function.
* @returns {Boolean}
*/
DEL:async(DATA,CALLBACK)=>await new Promise(async(t,i)=>{try{return 1==await E(await DATA)&&1==await w(await DATA.TABLE)&&1==await w(await DATA.ID)&&"READ_ONLY"!=await DATA.ID?await c.HAS({TABLE:await DATA.TABLE,ID:await DATA.ID},async w=>1==await w.SUCCESS?1==await w.VALUE&&0==await r.prepare(`SELECT VALUE FROM ${await DATA.TABLE} WHERE ID = (?)`).get("READ_ONLY").VALUE&&0==await r.prepare(`SELECT READ_ONLY FROM ${await DATA.TABLE} WHERE ID = (?)`).get(await DATA.ID).READ_ONLY?(await r.prepare(`DELETE FROM ${await DATA.TABLE} WHERE ID = (?)`).run(await DATA.ID),await t(!0)):await t(!1):await i(await w.ERROR)):await t(!1)}catch(a){return await i(await a)}}).then(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await a}):await a).catch(async a=>"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!1,ERROR:await a}):await i(await a))};return await t(await c)}catch(a){return await i(await a)}}).then(async i=>"function"==typeof OPTIONS?await OPTIONS({SUCCESS:!0,VALUE:await i}):"function"==typeof CALLBACK?await CALLBACK({SUCCESS:!0,VALUE:await i}):await i).catch(async i=>{if("function"==typeof OPTIONS)return await OPTIONS({SUCCESS:!1,ERROR:await i});if("function"==typeof CALLBACK)return await CALLBACK({SUCCESS:!1,ERROR:await i});throw await i}));